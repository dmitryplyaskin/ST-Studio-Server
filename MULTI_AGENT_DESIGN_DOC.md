## Дизайн‑док: ST Studio — расширяемые пайплайны/воркфлоу в SillyTavern (без форка ядра)

### Цель

Сделать **ST Studio** — расширение‑платформу, которая даёт пользователю гибкий “конструктор” поведения вокруг генерации (pre/post‑processing, хранение стейта, произвольные воркфлоу), так, чтобы:

- **Не форкать ядро** (или минимизировать изменения).
- **Не ломать UX**: блокировка UI, отмена, история чата, рендер, совместимость с существующими расширениями.
- **Сохранять совместимость** с текущим пайплайном ST: настройки провайдера/модели, WI/regex/инъекты, tool-calling, JSON schema и т.п.

Примечание: **мультиагентность** (несколько независимых запросов к LLM + синтез) — это один из возможных “инструментов/воркфлоу” внутри ST Studio, но не единственная цель.

### Нецели

- Полная изоляция контекстов “как в LangGraph/crewAI” внутри ядра ST.
- “Настоящий параллельный стрим в несколько сообщений” как first-class feature ядра.
- Полная интеграция агента как нового типа “main_api” (это уже требует рефакторинга).

---

## Доступные нам возможности в текущей архитектуре ST

### 1) Клиентский пайплайн генерации (основная точка)

- `public/script.js`:
  - `Generate(...)` — главный оркестратор UI/контекста/событий и запуск генерации.
  - `saveReply(...)` / `StreamingProcessor` — обновление чата, swipes, таймеры, события `MESSAGE_RECEIVED`.
- `public/scripts/openai.js`:
  - формирует `generate_data` и вызывает `/api/backends/chat-completions/generate`.
  - эмитит `event_types.CHAT_COMPLETION_SETTINGS_READY` с **готовым payload** (`generate_data`) для chat‑completions.

### 2) События (eventSource)

Критичные события/точки встраивания:

- `GENERATION_STARTED`, `GENERATION_AFTER_COMMANDS`, `GENERATION_STOPPED`, `GENERATION_ENDED`
- `CHAT_COMPLETION_SETTINGS_READY` — “слепок” готовых параметров chat-completions перед запросом на сервер
- `MESSAGE_RECEIVED`, `CHARACTER_MESSAGE_RENDERED`
- `TOOL_CALLS_PERFORMED` / `TOOL_CALLS_RENDERED` (для учета tool-calling)

### 3) Generate interceptor у расширений

`public/scripts/extensions.js` поддерживает `manifest.generate_interceptor`.
Интерсептор:

- получает `(chat, contextSize, abort, type)`
- может **отменить** штатную генерацию через `abort(true|false)`
- позволяет реализовать “перехват Generate()” без правок ядра: отменяем штатную генерацию и запускаем свою (например, мультиагентную).

### 4) Встроенный tool-calling (локальная “агентность”)

`public/scripts/tool-calling.js` уже умеет:

- регистрировать инструменты
- парсить tool calls (включая streaming)
- исполнять и сохранять результаты в чат
  Это важно для мультиагентности, потому что:
- “агенты” могут быть как отдельные параллельные вызовы, так и последовательные шаги с инструментами.
- нужно не ломать/не дублировать tool-calling (решение: либо выключать tools в “агентах”, либо поддерживать их аккуратно).

### 5) Серверные плагины (server plugins)

`src/plugin-loader.js` позволяет серверным плагинам:

- зарегистрировать роуты под `/api/plugins/<id>/...`
  Это удобный слой для:
- безопасного проксирования/лимитирования
- хранения состояния (кэш/очереди)
- “серверной” оркестрации без жёсткой привязки к DOM/глобальным переменным клиента

### 6) Универсальный эндпоинт генерации chat-completions

`src/endpoints/backends/chat-completions.js`:

- `POST /api/backends/chat-completions/generate`
- поддерживает много провайдеров и параметров (tools, json_schema, stream, и т.д.)
  Практический вывод:
- для “агентов” лучше использовать **тот же endpoint**, подавая “производный” `generate_data` от текущих настроек пользователя.

---

## Термины и определения

- **ST Studio**: расширение‑платформа, которое добавляет **пайплайн** вокруг генерации и предоставляет “инструменты/воркфлоу” (multi‑agent, валидатор действий, RAG, стейт‑машина, UI‑артефакты и т.д.).
- **Инструмент (Tool)**: конкретный режим/воркфлоу, который подключается к пайплайну (например, Multi‑Agent, Guard/Validator, RAG‑контекст, Reddit‑комментатор).
- **Процессор (Processor)**: шаг pre/post‑processing, который читает контекст и возвращает изменения/артефакты/патч стейта.
- **Артефакт (Artifact)**: данные для UI/пользователя/логов, которые **не обязаны** попадать в промпт (`messages`).
- **Стейт (State)**: состояние, которым управляет ST Studio (инвентарь, время, флаги, нужды персонажа и т.п.) — хранится отдельно от внутренних данных ST.
- **Агент**: конфигурация одной генерации (system/role/инструкции, модель, температура, лимиты, инструменты, пост‑обработка). _(Используется в инструменте Multi‑Agent.)_
- **Раунд**: параллельный (или ограниченно параллельный) набор вызовов агентов по одному пользовательскому запросу. _(Multi‑Agent.)_
- **Синтезатор**: финальная генерация, которая получает результаты агентов и формирует итог. _(Multi‑Agent.)_
- **Базовый payload**: `generate_data`, полученный из `CHAT_COMPLETION_SETTINGS_READY`, который гарантированно соответствует текущему провайдеру/настройкам ST.

---

## Архитектурные варианты (на примере инструмента Multi‑Agent)

### Вариант A (рекомендуемый): гибрид “клиентское расширение + серверный плагин”

#### Идея

- Клиентское расширение:
  - добавляет UI ST Studio (кнопка/меню) и запуск инструмента Multi‑Agent
  - перехватывает `CHAT_COMPLETION_SETTINGS_READY` и хранит **последний базовый payload**
  - запускает мультиагентный процесс через `/api/plugins/<id>/multi-agent/run` (server‑plugin)
  - отображает прогресс/результат в чате через `saveReply`/`StreamingProcessor`
- Серверный плагин:
  - принимает `{ baseGenerateData, agentsConfig, userMessageMeta }`
  - делает N запросов к `/api/backends/chat-completions/generate` (с лимитированием/очередью)
  - возвращает результаты + (опционально) SSE‑стрим прогресса

#### Плюсы

- **Меньше “DOM/глобального состояния”** на клиенте
- централизованное:
  - лимитирование параллелизма
  - ретраи/бэкофф
  - защита от злоупотреблений
  - возможность кэширования/дедупликации

#### Минусы

- сложнее разворачивать (нужен server plugin)
- всё равно есть “модель зависима от ядра” (изменение схемы `generate_data` потребует обновлений)

---

### Вариант B: чисто клиентское расширение

#### Идея

Расширение напрямую дергает `/api/backends/chat-completions/generate` несколько раз из браузера.

#### Плюсы

- проще (нет серверного плагина)
- быстрый прототип

#### Минусы (существенные)

- сложнее корректно:
  - ограничивать параллелизм/ретраи
  - управлять отменой (AbortController на каждый агент)
  - поддерживать стриминг/прогресс
- больше риск “сломать UX” (несколько запросов параллельно + один UI‑поток)

---

### Вариант C: “перехват Generate() через generate_interceptor”

#### Идея

Сделать расширение‑перехватчик:

- `generate_interceptor` отменяет штатный `Generate()` “немедленно”
- расширение само инициирует:
  - отправку пользовательского сообщения в чат
  - мультиагентные вызовы
  - финальное сохранение результата

#### Плюсы

- максимальный контроль поведения

#### Минусы

- высокий риск несовместимости:
  - группы, swipes, continue/impersonate, файлы/медиа, WI, regex, токены/таймеры
- нужна “очень аккуратная” интеграция с существующими событиями

---

## Рекомендуемая реализация (детально): вариант A

### Компоненты

#### 1) Клиентское расширение `st-studio` (инструмент Multi‑Agent как один из режимов)

Обязанности:

- **UI**: кнопка/панель конфигурации агентов (модель, temperature, роль, max_tokens, включение tools и т.п.)
- **Захват базового payload**:
  - слушаем `CHAT_COMPLETION_SETTINGS_READY`
  - сохраняем “последний хороший” `generate_data` (плюс метаданные: активный чат/персонаж/группа/тип генерации)
- **Запуск оркестрации**:
  - создаём “placeholder” сообщение (например: “Генерирую ответы агентов…”)
  - вызываем `/api/plugins/st-studio/multi-agent/run` с `baseGenerateData` + `agentsConfig`
- **Отображение результатов**:
  - по завершению: обновляем placeholder на финальный ответ
  - опционально: добавляем “системное” сообщение со сводкой по агентам (для дебага)
- **Отмена**:
  - единый “runId” и локальный AbortController
  - кнопка “stop”/реакция на `GENERATION_STOPPED`

#### 2) Server‑plugin `st-studio` (id: `st-studio`)

Обязанности:

- валидировать вход
- формировать N запросов на `/api/backends/chat-completions/generate`
- ограничивать параллелизм (например 2–3 одновременных)
- возвращать результаты (и/или прогресс)

Примечание: инструмент Multi‑Agent — это часть server‑плагина **`st-studio`** (роуты могут быть сгруппированы под `/api/plugins/st-studio/multi-agent/...`).

---

## Поток данных (основной сценарий)

### Шаг 0: Пользователь пишет сообщение

Обычный UX ST: пользователь вводит текст и нажимает “Send”.

### Шаг 1: Мы получаем базовый payload

При первой штатной генерации (или при специальном “dryRun‑сборе”) ST эмитит:

- `CHAT_COMPLETION_SETTINGS_READY(generate_data)`

Мы сохраняем `generate_data` как `baseGenerateData`.

### Шаг 2: Запуск мультиагентного режима

Когда пользователь запускает инструмент Multi‑Agent (например, кнопка “ST Studio → Multi‑Agent run”):

- клиент создаёт placeholder через `saveReply(...)` (или добавляет системное сообщение)
- отправляет запрос на серверный плагин:
  - `baseGenerateData` (как базу настроек)
  - `agentsConfig[]`
  - `inputText` (или используем уже вставленное user‑сообщение в messages)

### Шаг 3: Вызовы агентов (сервер)

Для каждого агента:

- делаем **копию** `baseGenerateData` → `agentData`
- модифицируем:
  - system/инструкции (через добавление/замену system message)
  - `model`, `temperature`, `max_tokens` / `max_completion_tokens` (в зависимости от модели)
  - `tools` (включить/выключить согласно политике)
- отправляем в `/api/backends/chat-completions/generate`
- сохраняем сырой ответ + извлечённый текст + метаданные (токены/ошибки/латентность)

### Шаг 4: Синтез

Синтезатор — ещё один вызов (либо один из агентов):

- получает результаты агентов как контекст
- выдаёт финальный ответ

### Шаг 5: Отображение в чате

Клиент:

- заменяет placeholder на финал
- опционально добавляет “детали” под спойлером

---

## Ключевые решения и политики

### 1) Где хранить/как получать настройки пользователя

Рекомендуется:

- **не собирать settings вручную**
- **использовать `generate_data` из `CHAT_COMPLETION_SETTINGS_READY`**

Пояснение:

- `generate_data` уже корректно собран под текущий провайдер и модель (включая спец‑поля вроде json_schema, reasoning_effort, и т.д.)
- это снижает риск “мелких несовместимостей” между провайдерами

### 2) Что менять в payload для агента

Минимально‑безопасный набор:

- `messages`:
  - добавить system message “роль агента” или отдельный блок инструкций
  - либо вставить “agent prefix” в последнюю user‑реплику (хуже, но проще)
- `model`, `temperature`, `top_p`, `max_tokens`/`max_completion_tokens`
- `stream`: для агентов по умолчанию `false`, для синтеза можно `true`

### 3) Tools / tool-calling

Базовые варианты:

- **Policy T0 (самый безопасный)**: tools выключены у агентов, включены только у синтеза (или вообще выключены).
- **Policy T1 (умеренный)**: tools разрешены только у “планировщика” (одного агента), остальные без tools.
- **Policy T2 (сложный)**: tools разрешены всем агентам, но результаты tool calls сохраняются отдельно и в финал попадают как цитаты/артефакты.

Риск:

- tool-calling может запускать дополнительные шаги/рекурсию и резко увеличить стоимость/время.

### 4) Параллелизм и лимиты

Рекомендация:

- лимитировать параллелизм на сервере: 2–3 concurrent
- делать ретраи только на сетевые/429/5xx с backoff
- иметь “план деградации”: если агент упал, синтезатор получает “ошибка агента” вместо текста

### 5) Стриминг

Рекомендуемая стратегия:

- **стримить только синтез** (финальный ответ)
- для агентов показывать прогресс в placeholder (например, “Агент 2/5 готов”)

Причина:

- ST streaming тесно привязан к “одному активному сообщению” и UI‑циклу.

### 6) Отмена (Cancel)

Должно работать на 3 уровнях:

- клиент: “Stop” → отправляет `/api/plugins/st-studio/multi-agent/cancel?runId=...`
- сервер: хранит AbortController на каждый активный fetch и отменяет
- при отмене: возвращать частичные результаты и помечать run как cancelled

---

## Типовые проблемы и пути решения

### Проблема: несовместимость payload между моделями/провайдерами

**Решение**:

- всегда стартуем от `baseGenerateData`
- меняем только 3–6 полей
- не пытаемся “унифицировать” все провайдеры в расширении

### Проблема: несколько агентов “портят контекст” WI/regex/инъектами

**Решения**:

- использовать тот же `messages`, который ST уже подготовил (включая WI/AN/regex), и добавлять роль агента поверх
- опционально: отдельный режим “агенты без WI” (удалить инъекты) — как настройка

### Проблема: ломаем историю чата/свайпы/таймеры

**Решения**:

- не создавать N сообщений в чат по одному на агента по умолчанию
- хранить результаты агентов в `extra` финального сообщения (или отдельным системным “details” сообщением)
- использовать `saveReply` и `addOneMessage`, чтобы сохранить нативное поведение ST

### Проблема: безопасность (инъекции, утечка ключей, SSRF)

**Решения** (для серверного плагина):

- не принимать “произвольный URL” от клиента
- не принимать “произвольные headers” от клиента
- дергать только внутренний `/api/backends/chat-completions/generate`
- валидировать размер `baseGenerateData/messages` (лимит на длину/кол-во сообщений)

### Проблема: нагрузка/стоимость

**Решения**:

- лимит количества агентов (например 2–6)
- лимит `max_tokens` на агента
- сделать “cheap mode”: дешёвые модели на агентах, дорогая — на синтезе

---

## Минимальная спецификация интерфейсов

### Клиент → server‑plugin (инструмент Multi‑Agent): `POST /api/plugins/st-studio/multi-agent/run`

Примерная схема:

- `runId`: string (генерируется на клиенте или сервере)
- `baseGenerateData`: object (как из `CHAT_COMPLETION_SETTINGS_READY`)
- `agents`: array of
  - `name`
  - `roleInstruction` (system text)
  - `model?`
  - `temperature?`
  - `max_tokens?`
  - `enableTools?`
- `synthesizer`: object (как agent, но отдельно)
- `options`:
  - `concurrency`
  - `streamFinal` (boolean)
  - `includeAgentDetailsInResponse` (boolean)

### Сервер → клиент: результат

- `finalText`
- `agentResults[]`: `{ name, text, raw?, error?, durationMs? }`
- `cancelled`: boolean

Опционально (если SSE):

- `event: progress` с `{ completed, total, agentName }`
- `event: final` с результатом

---

## План внедрения (эволюционно)

### Этап 0: “Core MVP” (то, с чего начинаем)

- клиентское расширение **ST Studio**
- pre/post‑processing пайплайн (процессоры + артефакты)
- по умолчанию **без** перехвата `Generate()` (работаем аккуратно через события/точки встраивания)
- артефакты/“саб‑инфу” не засовываем в `messages` без необходимости (чтобы не раздувать контекст)
- минимальное хранение стейта: сначала можно “в памяти”, но предпочтительно сразу вынести в server‑plugin (см. блок про `data/{user}`)

### Этап 1: стабильность и persistence

- server‑plugin **ST Studio** как “надёжное хранилище” стейта на диске + валидация/миграции/атомарная запись
- механика `revision`/конфликты (опционально, но желательно)

### Этап 2: инструмент Multi‑Agent (опционально)

- оркестрация N вызовов + синтез (по схеме выше)
- лимитирование параллелизма/ретраи/отмена
- политики tools (T0/T1/T2)
- “раунды” (например: план → критика → исправление → синтез)

### Этап 3: графовый редактор и произвольные workflow (опционально)

- React‑остров (micro‑frontend) для визуального конфигурирования
- сохранение/загрузка графов в стейт ST Studio
- расширенные валидаторы/интеграции (RAG, строгие правила, скрытый контекст и т.д.)

---

## Дополнение: “ядро” первой итерации — Pre/Post‑processing вместо полноценного “менеджера агентов”

Идея на 1‑ю итерацию: **не** пытаться сразу сделать “систему управления агентами”, а заложить **универсальный пайплайн вокруг одной штатной генерации**:

- **Pre‑processing (до основного запроса к LLM)**: по заданным инструкциям “агент/процессор” подготавливает контекст, валидирует ввод пользователя и при необходимости добавляет данные в историю/промпт.
- **Post‑processing (после ответа LLM)**: по результату генерации обновляет “состояние мира/пользователя”, формирует артефакты UI, и (опционально) добавляет служебные записи.

Это даёт “агентность” (валидация, дайсы, RAG, state‑машина) **без** сложной оркестрации N вызовов модели.

### Типовые кейсы Pre‑processing (пример: “гвард”/валидатор действий)

Пример: пользователь пишет “убиваю дракона зубочисткой”, но в рамках сеттинга это невалидно.

Pre‑процессор может:

- **валидировать действия** и вернуть “возможные варианты развития событий” (что реалистично/нереалистично);
- **сделать проверку** (бросок кубика / проверка навыка / модификаторы от экипировки);
- **достать контекст из RAG** (правила мира, лор, характеристики монстров/оружия);
- **добавить/изменить инструкции** модели (например: “соблюдай реализм сеттинга; если действие невозможно — предложи альтернативы”);
- **прервать генерацию** и вывести ответ “валидатора” вместо обращения к LLM (как отдельный режим).

### Типовые кейсы Post‑processing

Post‑процессор может:

- **обновить состояние** (инвентарь, деньги, время, одежда, “статы”, квесты);
- **сформировать “state diff/summary”**: коротко описать, что изменилось, для следующего шага;
- **создать “саб‑инфу”** для пользователя, которая не обязана попадать в контекст (панель инвентаря, таблица, лог проверок, “комментарии как на Reddit” и т.п.);
- **добавить служебные сообщения** (например, в виде системной заметки или скрытого блока details).

### Критически важное правило: разделить “контекст для модели” и “артефакты для UI”

Чтобы не раздувать промпт и стоимость, полезно разделить результаты процессоров на два канала:

- **Context mutations**: то, что реально влияет на следующий запрос (инъекции в `messages`, system‑инструкции, RAG‑контекст, короткая фиксация результата дайса при необходимости консистентности).
- **Artifacts / Side‑info**: то, что **не надо** кормить модели (панели, HTML, расширенная аналитика, “реддит‑комменты”, диагностические отчёты валидатора).

Практически: артефакты хранить в `extra`/details финального сообщения или в отдельном UI‑слое, а в `messages` добавлять только минимально необходимое.

### Привязка к существующему пайплайну ST

Эта модель хорошо ложится на текущие точки встраивания:

- **Pre**: вокруг момента, когда готов `generate_data` (например, через `CHAT_COMPLETION_SETTINGS_READY` и/или прямо перед отправкой в `/api/backends/chat-completions/generate`).
- **Post**: после генерации, опираясь на `MESSAGE_RECEIVED` / `CHARACTER_MESSAGE_RENDERED`, обновляя `chat[messageId].extra`/details и UI.

### Минимальная форма интерфейса “процессора” (идея)

Достаточно простого, но стабильного контракта:

- `pre(ctx) -> { allow/deny, patches?, artifacts?, statePatch? }`
- `post(ctx) -> { patches?, artifacts?, statePatch? }`

Где `ctx` включает: последний user input, `baseGenerateData/messages`, метаданные чата/персонажа/режима генерации, и доступ к “стору состояния” (инвентарь/время и т.п.).

### Риски первой итерации и как их обойти

- **Инфляция контекста**: по умолчанию не добавлять пост‑артефакты в `messages`.
- **Недетерминизм (дайсы)**: логировать бросок как артефакт; в контекст добавлять только краткую запись (если важно для консистентности).
- **Взаимное влияние процессоров**: фиксировать порядок, вводить `id` и “уже применено” (идемпотентность в рамках одного шага).

---

## Будущее: сложный UI (граф/flow) в jQuery‑тавёрне без форка ядра

Если в дальнейшем появится желание дать пользователю управление “графом” (условный LangGraph‑подобный workflow) и сделать визуальный редактор (например, на `react-flow`), это **не требует** перевода всего расширения на React и “переписывания” UI SillyTavern.

Рекомендуемый паттерн: **React как “остров” (micro‑frontend) внутри расширения**.

### Как React‑остров уживается с jQuery/vanilla ST

- Расширение создаёт **контейнер** (div) в нужном месте UI (панель/модалка/вкладка/док‑окно).
- Внутрь контейнера монтируется React‑приложение (`ReactDOM.createRoot(container).render(...)`).
- **React управляет только своим контейнером** и не “трогает” DOM тавёрны вокруг — тогда конфликтов с jQuery почти не бывает.

### Связь UI (React) ↔ SillyTavern (jQuery)

Вместо попыток “порталить” весь ST под React, делается тонкий мост:

- **Bridge‑модуль расширения**: небольшое JS API, которое:
  - подписывается на события ST (`eventSource`)
  - предоставляет React‑части функции “запустить пайплайн”, “получить `baseGenerateData`”, “применить граф”, “сохранить/загрузить конфиг” и т.п.
- **Событийная модель**: React‑остров слушает события ST и обновляет состояние (активный чат/персонаж, старт/стоп генерации), а действия пользователя отправляет обратно через bridge.
- **Серверный плагин** (опционально): хранение графов, кэш, выполнение и тяжёлая логика — через `/api/plugins/<id>/...`, чтобы не тащить всё в браузер.

### Сборка (Vite/Webpack) и дистрибуция “готового кода”

Да, для React‑острова нужен бандлер (чаще всего проще **Vite**):

- исходники лежат в папке расширения (например, `ui/`),
- сборка генерирует **статические файлы** (`dist/index.js`, `dist/index.css`, assets),
- при установке расширения пользователь получает уже собранный бандл — без необходимости ставить Node.

### Изоляция стилей

Чтобы не конфликтовать с глобальными стилями ST:

- CSS Modules/префиксация/namespace‑класс на root контейнере;
- при необходимости — Shadow DOM для жёсткой изоляции (не обязательно в MVP).

---

## ST Studio: минимальный server‑plugin для хранения “своего” стейта на диске (`data/{user}`)

Цель на ранних итерациях: **не мутировать внутренние данные SillyTavern “куда не следует”**, а хранить нужный ST Studio state отдельно на диске, чтобы:

- перед каждым запуском всегда был **валидный и актуальный** state;
- state переживал перезапуск/обновление браузера;
- состояние можно было безопасно версионировать и мигрировать;
- расширение не зависело от форматов `chat`/персонажей/внутренних структур ST.

### Где хранить

Важно: SillyTavern поддерживает **несколько пользователей**, поэтому путь должен быть не `data/user`, а `data/{user}`, где `{user}` — активный профиль пользователя.

Рекомендуемое место: `data/{user}/st-studio/...`

Пример структуры:

- `data/{user}/st-studio/state/global.json` — глобальные настройки/профили ST Studio
- `data/{user}/st-studio/state/chats/<chatKey>.json` — состояние конкретного чата
- `data/{user}/st-studio/state/characters/<characterKey>.json` — состояние “на персонажа” (если нужно)
- `data/{user}/st-studio/state/groups/<groupKey>.json` — состояние “на группу” (если нужно)
- `data/{user}/st-studio/runs/<runId>.json` — опционально: логи прогонов/аудит/диагностика

`<chatKey>/<characterKey>/<groupKey>` — стабильный идентификатор (выбирается позже, когда определимся с тем, что ST считает “id” в разных режимах).

### Что должен делать серверный плагин (MVP)

- **Load/Save** стейта на диск.
- **Валидация и дефолты**: сервер **всегда** возвращает валидный объект (если файла нет — возвращает дефолтный state).
- **Версионирование и миграции**: поле `version` + преобразование старых версий при чтении/записи.
- **Атомарная запись**: писать через временный файл `*.tmp` и `rename` поверх основного, чтобы не получать битые JSON при падениях.
- **Защита от конфликтов** (опционально, но очень желательно): `revision`/`etag` и 409 при “перезаписи из другой вкладки”.

### Минимальные эндпоинты (MVP)

1. **Загрузка стейта**

- `GET /api/plugins/st-studio/state?scope=chat&key=<chatKey>`
- ответ: `{ scope, key, revision, state }`
- если файла нет: `state` = дефолтный, `revision` = 0

2. **Сохранение стейта**

- `POST /api/plugins/st-studio/state`
- тело: `{ scope, key, expectedRevision?, state }`
- сервер:
  - валидирует и нормализует (дефолты/схема)
  - мигрирует по `version`
  - проверяет `expectedRevision` (если задан)
  - пишет на диск атомарно
  - возвращает новый `{ revision }`

3. (Опционально) **Patch**

- `POST /api/plugins/st-studio/state/patch`
- тело: `{ scope, key, expectedRevision?, patch }`
- полезно, чтобы не гонять большой `state` целиком (формат patch выбирается позже: merge‑patch или json‑patch).

4. (Опционально) **Health**

- `GET /api/plugins/st-studio/health`
- чтобы UI мог показывать “плагин доступен/нет”.

### Как это стыкуется с Pre/Post‑processing

- **Pre**:

  - клиент грузит state из server‑plugin
  - прогоняет pre‑процессоры
  - при изменениях — сохраняет state (и/или пишет короткий “след” в контекст, если требуется)
  - запускает основную генерацию

- **Post**:
  - после ответа модели клиент вычисляет `statePatch`/изменения
  - сохраняет state через server‑plugin
  - UI‑артефакты (панели/HTML/логи) рендерит локально, не раздувая `messages`
